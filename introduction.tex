\section{Introduction}
%what is the problem
Data indexing is an important component of any practical data storage system/DBMS.
A data index essentially accelerates the read path of the data store by maintaining
fast metadata lookup for already written/stored data. However, the index itself 
needs to be persistent in addition to the stored data. Persistent index enables 
instant recovery for the DBMS as we do not have to rebuild the index from scratch.

Maintaining consistent persistent index has its own overheads. First, we have to keep 
index updated, to keep correctness between index and the data it points to. We identify
this as runtime-consistency. Next, we should make sure that, our index remain consistent
even after a unplanned system crash.That is, during index updates we have to maintain
all-or-nothing semantics by using some form of logging protocol (e.g. Aries).


Furthermore maintaining persistent index for block based storage is challenging.
First, disk I/O based DBMS system (e.g. SSD) access data in blocks. That is 
even if you are accesing one byte of data, you have to bring in the whole block in to the
volatile memory. Second, these devices have low access latency compared to volatile main memory --
two orders of magnitude slower than DRAM. Therefore, the disk based persistent indexes are
stored out of band (in a seperate file structure) from the actual data. This design
decision benefits the index traveral. This is because, such data organization enables
maximum index data availability on volatile buffer-caches.


\section{Motivation}
%why is this problem important
Non volatile memory(NVM) is an emerging storage technology that promises byte addressable 
persistency. NVMs have read/write latencies that are comparable to DRAM and the device 
writes are durable. Fast accesses latencies and byte addressablity enables this new device
to be placed alongside with DRAM main memory, thus providing direct persistent load/stores
from the processor.




\cite{pmwcas}



\section{NVStore}
%proposed solution

