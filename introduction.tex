\begin{abstract}
	Byte addressable Non-volatile memory(NVM) technologies such as Intel's
3DXpoint has entered in to the commodity compute platforms. These
new storage class memory demand new breed of database management system 
software stacks. 
In this paper, we propose Blizzard, a reliable persistent storage stack,
that uses NVMs and modern networking system software to provide a reliable
persistent data-storage. Blizzard combines a network optimized Paxos like 
operation repication stack and a persistent data-structure library to 
provide a fast and relibale persistent data storage stack that supports
familiar C++ STL library's programming abstraction.

\end{abstract}

\section{Introduction}
%what is the problem

Managing persistent data has been a challenge since the very early days of computing.
Community have tackled the persistent data challenge via system program abstractions
such as file-systems, data-base management systems, kv-stores, etc.
The non-volatile memory technology solutions such as Intel's 3DXpoint is about to
enter the commodity market. These new devices offer byte addressable persistency
with low latency reads and writes.

Systems community was quick to adopt NVM device properties in their system software
designs. There has been NVM optimized file-systems,databases,kv-stores and programming abstractions.
However, the existing persistent memory programming abstractions in the form the kv-stores, posix 
file APIs and SQL interfaces do not provide data reliability as a first class system
property. That is, as the NVM modules store data local to the machine, there is a possibility of 
losing data in an event of catastrophic machine failure. The existing systems provide reliablity
via data-replication, but such solution are more of an after thought.

Furthermore, the state of the art persistent memory storage abstractions such as DBMSs file-systems
follow the traditional wisdom of storing persistent data with different data layouts/formats
than the application structures that they represent. This scenario is commonly known as 
the impedence mismatch of volatile and peristent data. The reason for such mismatch stems 
from mainly due to their storage device characteristics. The persistent devices used to be
block addressabilty while the main memory is byte addressable.

With ever improving network hardware and low latency network systems software stacks, 
the data replication costs have reduced signficantly over the years. Combined with NVM's
fast stores, it is now possible provide reliable persistent storage with minimal impedence
mismatch. We design and implement Blizzard, a set of programming abstractions that provides 
reliable and persistent data storage. First, Blizzard bridges volatile and persistent impedence
mismatch by directly manipulating persistent memory resident data-structures. Second, it helps
persistent storage programming by supporting well-known C++ STL like persistent containers.
Third, Blizzard improves the reliability of these persistent containers using NVM aware replication library.


\section{Motivation}
%why is this problem important
Non volatile memory(NVM) is an emerging storage technology that promises byte addressable 
persistency. NVMs have read/write latencies that are comparable to DRAM and the device 
writes are durable. Fast accesses latencies and byte addressablity enables this new device
to be placed alongside with DRAM main memory, thus providing direct persistent load/stores
from the processor. Furthermore NVMs have high form factor (high capacity devices) thus
making them ideal devices for data storage. 

There has been numerous effort to adopt volatile memory like data-structures with persistent
memory. Community has worked on efficient crash-consistency mechanism, concurrency and persistent
memory interaction, etc. 

However, unlike volatile transient data, persistent data usages
demand reliability from the system software hardware/software, because the long business critical data
in the form of application state gets stored on them. Therefore, persistent data storage stacks such
as databases provide data-reliability via data replication. Data replication is costly and often
greatly slows down application. Therefore, the common practice is to stay away from reliable data
storage or to relax some of the reliability guarantees.

Network system software stacks performance have greatly improved over the years. More importantly
the network system software designed to work well with memory hardware. With NVM offering persistent
storage we argue that well designed system software stack can provide both persistent and reliable
data guarantees at a lower performance cost than that of today's state of the art.

\section{Blizzard}
We propose Blizzard, a reliable persistent programming substrate. Blizzard provides applications
with reliable persistent containers that closely matches the ones provided by C++ STL containers.

\subsection{Persistent Data Structures}

C++ STL containers are a popular programming abstraction among software developers. This is because,
more often than not, the application's runtime state can be represented by few commonly used 
data-structures.  However, the C++ STL containers are meant to use with volatile memory, thus
lacks an failure-atomic udpate support in their existing form.

Unlike, volatile main memory, the data stored on persistent memory survives application restarts,
node restarts -- they are persistent data after all. Hence, we have to guard the data updates 
against unplanned application crashes, node crashes. Write-ahead logging is a well studied
system technique that guarantees all or nothing property during persistent storage updates.
With NVMs we can use value logging in the form of redo/undo logs.

\begin{figure}[]   
	\centering
	\includegraphics[width=\linewidth]{figures/design.pdf} 
	\caption{\bf Node structure of a RBTree node. We do not store key vlaues in the internal nodes. We simply
	store a persistent pointer in to the external key.} 
	\label{fig:zerocopy} 
\end{figure}

Intel PMDK project implements wide-array of persistent memory data-structures. 
We use them as our building blocks as the sources are freely available. 

\subsection{Relaible Persistent Containers}

We use state machine replication (SMR) as our replication mechanism. SMR's can tolerate
up to 'f' node failures, given number of replicas are '2f+1'. Furthermore, SMRs improves
availability, due to dynamic leader election and log-sync up, any of our follower replicas
can take over the duties of master node in an event of node failure.

Our replication layer support logical operation replication. We plug our containers to work with
the the replicated operations. 

We expose below set of operations to the end user applications via client API.

\begin{itemize}
\item Create container - create and initialize a given STL container type for given data types
\item Insert - insert value in to the container.
\item Get - retrieve value from the container.
\end{itemize}

A typical STL container inteface supports more operations than listed above. We plan to support them
as and wehen needed for our application benchmakr needs.

\subsection{Primitive for Reliable, Persistent Data-structure Creation}

Above integration between persistent data-structures and log replicaiton layer
gives reliablity to our persistent data structures. However, the application developers 
still have to explicitly call Blizzard API to manipulate persistent state of the application.
Multi-word CAS is a programming primitive that support both concurrency and persistent. Similar
primitive that extends the persistency and concurrency with reliability would be very useful
programming tool.

We are exploring this path at the moment. However, as our log-replicaiton layer relies on operation/logical
logging we have not yet figured out a way to seamlessly extend the current work in to PMWCAS.




