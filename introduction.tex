\section{Introduction}
%what is the problem

Managing persistent data has been a challenge since the very early days of computing.
Community have tackled the persistent data challenge via system program abstractions
such as file-systems, data-base management systems, kv-stores, etc.
The non-volatile memory technology solutions such as Intel's 3DXpoint is about to
enter the commodity market. These new devices offer byte addressable persistency
with low latency reads and writes.

Systems community was quick to adopt NVM device properties in their system software
designs. There has been NVM optimized file-systems,databases,kv-stores and programming abstractions.
However, the existing persistent memory programming abstractions in the form the kv-stores, posix 
file APIs and SQL interfaces do not provide data reliability as a first class system
property. That is, as the NVM modules store data local to the machine, there is a possibility of 
losing data in an event of catastrophic machine failure. The existing systems provide reliablity
via data-replication, but such solution are more of an after thought.

Furthermore, the state of the art persistent memory storage abstractions such as DBMSs file-systems
follow the traditional wisdom of storing persistent data with different data layouts/formats
than the application structures that they represent. This scenario is commonly known as 
the impedence mismatch of volatile and peristent data. The reason for such mismatch stems 
from mainly due to their storage device characteristics. The persistent devices used to be
block addressabilty while the main memory is byte addressable.

With ever improving network hardware and low latency network systems software stacks, 
the data replication costs have reduced signficantly over the years. Combined with NVM's
fast stores, it is now possible provide reliable persistent storage with minimal impedence
mismatch. We design and implement Blizzard, a set of programming abstractions that provides 
reliable and persistent data storage. First, Blizzard bridges volatile and persistent impedence
mismatch by directly manipulating persistent memory resident data-structures. Second, it helps
persistent storage programming by supporting well-known C++ STL like persistent containers.
Third, Blizzard improves the reliability of these persistent containers using NVM aware replication library.


\section{Motivation}
%why is this problem important
Non volatile memory(NVM) is an emerging storage technology that promises byte addressable 
persistency. NVMs have read/write latencies that are comparable to DRAM and the device 
writes are durable. Fast accesses latencies and byte addressablity enables this new device
to be placed alongside with DRAM main memory, thus providing direct persistent load/stores
from the processor. Furthermore NVMs have high form factor (high capacity devices) thus
making them ideal devices for both persistent index and data storage. 


First, some of the assumptions that were made during the design of disk oriented persistent
indexes does not hold true anymore, 1) We can access NVM resident data at byte granularity similar to
DRAM data acesses. 2) The NVMs provide load store accesses at DRAM speed. Therefore, we can
possibly store index, alongside the actual data as the index retrival is not slowed down by
accompanying data. Furthermore, the use of DRAM buffer-cache is redundant as the NVMs are 
as good as DRAM in terms of access latency.


\section{Blizzard}
%proposed solution

We propose Blizzard, a reliable persistent programming substrate. Blizzard provides applications
with reliable persistent containers that closely matches the ones provided by C++ STL containers.

\subsection{Persistent Data Structures}

C++ STL containers are a popular programming abstraction among software developers. This is because,
more often than not, the application's runtime state can be represented by few commonly used 
data-structures.  However, the C++ STL containers are meant to use with volatile memory, thus
lacks an failure-atomic udpate support in their existing form.

Unlike, volatile main memory, the data stored on persistent memory survives application restarts,
node restarts -- they are persistent data after all. Hence, we have to guard the data updates 
against unplanned application crashes, node crashes. Write-ahead logging is a well studied
system technique that guarantees all or nothing property during persistent storage updates.
With NVMs we can use value logging in the form of redo/undo logs.

\begin{figure}[]   
	\centering
	\includegraphics[width=\linewidth]{figures/design.pdf} 
	\caption{\bf Node structure of a RBTree node. We do not store key vlaues in the internal nodes. We simply
	store a persistent pointer in to the external key.} 
	\label{fig:zerocopy} 
\end{figure}

Intel PMDK project implements wide-array of persistent memory data-structures. 
We use them as our building blocks as the sources are freely available. 

\subsection{Relaible Persistent Containers}







\subsection{Primitive for Reliable, Persistent Data-structure Creation}

