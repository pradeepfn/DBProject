\section{Implementation}
%how to validate implementation
\noindent{\bf Persistent memory hardware} We emulate persistent memory using volatile DRAM memory. NVMs are slower than DRAM, so we account for 
slow NVM latency using memory throttling. The modern CPUs allow us to configure the duty cycle value in the memory channel. We use that
facility to throttle the bandwidth of the DRAM memory device, reducing the bandwidth and latency of the DRAM reads/writes. 

\noindent{\bf Persistent containers}
We use persistent data-structure implementations of Intel PMDK to model our persistent containers. The PMDK's goal is not to 
create persistent containers. Hence we had to wrap some of their persistent memory data-structures to fit our container model.
e.g.: Wrapping B+tree with map interface.

\noindent{\bf Data Replication}

We use log replication system software layer called cyclone~\cite{cyclone} for our data replication. Cyclone implements 
state machine replication with Raft as the consensus protocol. Cyclone network transports use highly optimized 
userspace Intel's data plane development kit (DPDK) transport stack. Due to this, we had to port YCSB benchmark to
use same DPDK transport for performance reasons.

\section{Evaluation}
%evaluate performance

First we evaluate the basic performance characteristic of our proposed system using well known benchmark -- YCSB. 
We chose YCSB, because its key-value operations fits well for our container interfaces. We then compare and contrast
the performance numbers with state of the art key-value store from Facebook -- RocksDB ~\cite{rocksdb}. Work items involve;
\begin{itemize}
\item Port containers to work with replication software
\item Port RocksDB to work with cyclone.
\item Port YCSB to work with DPDK transport
\item Runs benchmarks, gettingn numbers
\end{itemize}


Next,we evaluate our system with a real application workload. In this experiment setup, we try to understand the costs
and benefits involved while using a reliable persistent containers as the basic application's peristent storage abstraction.
To that end we plan to port a well known application to use our storage primitives. Work items involve;
\begin{itemize}
\item Porting existing app to work with our generalized remote Blizzard API.
\item Running benchmark on the application, with and without Blizzard storage model.
\end{itemize}


\section{Project Goals}
%project goals description
We have identified the following goals for our project.
\begin{itemize}
    \item {\bf The 75$\%$ goal:} 1) Porting a Tree (range lookup) and Map ( point lookup) data structure as a reliable persistent containers. 2) Implementing client side library routines to interact with those containers over the network. 
    \\ \\
    At first, we spend couple weeks exploring different ideas. Our original thought was to extend the database indexing process to the non-volatile memory. However, we realized that data replication actually introduces large amount of overhead to the system. Therefore, we switched to designing a reliable protocol for database data. For the 75$\%$ goal, we utilize the pmem library to emulate the non-volatile memory and successfully port the client side library with containerized service.
    \\
    \item {\bf The 100$\%$ goal:} 1) Port YCSB benchmark to work with our containers. 2) Port a state of the art kv-store (RocksDB). 3) Using ported YCSB benchmark client, report numbers for Blizzard containers and competing state of the art. ( RocksDB ).
    \\ \\
    YCSB is a comprehensive test benchmark provided by Yahoo open source. It is mainly coded in Java. Users can create a interface in YCSB to interact with the actual DBMS and the performance will be tested through the interface. The major issue of this goal is that YCSB is mostly in Java, but our implementation is in C++. Therefore, for this goal, we utilized a already implemented driver from Pelaton to interact with the YCSB testing benchmark. 
    \\
    \item {\bf The 125$\%$ goal:} Extend and PMWCAS to support reliability. This include design of the primitive as it is not straight forward at this point to design it.
    \\ \\
    We have learned PMWCAS and tried to port it into our framework, but due to its complexity of dealing with multi-word concurrency update, we are not able to port it into our prototype. 
\end{itemize}



\section{Related Work}

PMWCAS~\cite{pmwcas} is a programming primtive that supports both persistency and multiword updates.
It extends well known CAS pritmive with multiword support while supporting same all or nothing
programming semantics of CAS. Furthermore, it extends the CAS to be persistent memory aware by
adding support for durability semantics ( fences and cache-line flushes).

Intel PMDK~\cite{pmdk} provides persistent memory aware data-structures. But they lack the reliability semantics.

\section{Conclusion}
In this project, we successfully design a non-volatile memory based storage stack Blizzard. The proposed stack uses non-volatile memory and modern networking system to provide a fast and also reliable persistent data storage. In our work, we show that even though logical data replication is not common in non-volatile memory domain, with careful adoption, we are able to achieve good performance. In addition, we design a prototype in our work, which shows good throughput and latency compared to previous work. We believe that the system can be adopted with other real world applications and also achieve good performance. 

\section{Future Work}
In this work, the idea is only tested in a basic prototype, but the real world application may introduce more random behaviors compared to an idealized prototype. Therefore, the next step is that we can extend our prototype to real world application that actually performs select or join operations. We have made some progress on Lobsters web app which is similar to Hackernews, but we expect to extend our framework and test it out on other real world applications. 

In this work, we did not get a chance to evaluate the PMDK physical replication implementation. In this future, we will think about how to comprehensively evaluate the physical replication implementation's performance. 
